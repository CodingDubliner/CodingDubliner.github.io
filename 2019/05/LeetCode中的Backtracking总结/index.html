<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="LeetCode 中的 Backtracking 总结"><meta name="keywords" content="LeetCode,Backtracking"><meta name="author" content="Dubliner"><meta name="copyright" content="Dubliner"><title>LeetCode 中的 Backtracking 总结 | Dubliner</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script><!-- hexo-inject:begin --><!-- hexo-inject:end -->var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><!-- hexo-inject:begin --><!-- hexo-inject:end --></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#基础模板"><span class="toc-number">1.</span> <span class="toc-text">基础模板</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#子集生成"><span class="toc-number">2.</span> <span class="toc-text">子集生成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#无边界限制——-Basic-Subsets"><span class="toc-number">2.1.</span> <span class="toc-text">无边界限制—— Basic Subsets</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#无重复元素的-Subsets"><span class="toc-number">2.1.1.</span> <span class="toc-text">无重复元素的 Subsets</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#有重复元素的-Subsets"><span class="toc-number">2.1.2.</span> <span class="toc-text">有重复元素的 Subsets</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#初尝边界——Combination"><span class="toc-number">2.2.</span> <span class="toc-text">初尝边界——Combination</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Basic-Combination"><span class="toc-number">2.2.1.</span> <span class="toc-text">Basic Combination</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Combination-Sum"><span class="toc-number">2.2.2.</span> <span class="toc-text">Combination Sum</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Combination-Sum-II"><span class="toc-number">2.2.3.</span> <span class="toc-text">Combination Sum II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Combination-Sum-III"><span class="toc-number">2.2.4.</span> <span class="toc-text">Combination Sum III</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Combination-Sum-IV"><span class="toc-number">2.2.5.</span> <span class="toc-text">Combination Sum IV</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Basic-Recursion"><span class="toc-number">2.2.5.1.</span> <span class="toc-text">Basic Recursion</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Memorization"><span class="toc-number">2.2.5.2.</span> <span class="toc-text">Memorization</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Dynamic-Programming"><span class="toc-number">2.2.5.3.</span> <span class="toc-text">Dynamic Programming</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Follow-Up"><span class="toc-number">2.2.5.4.</span> <span class="toc-text">Follow Up</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Factor-Combinations"><span class="toc-number">2.2.6.</span> <span class="toc-text">Factor Combinations</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/head.jpg"></div><div class="author-info__name text-center">Dubliner</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">1</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">2</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/bg.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Dubliner</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">主页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span></div><div id="post-info"><div id="post-title">LeetCode 中的 Backtracking 总结</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-05-28</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>递归函数不再调用它本身，而是返回上一层调用，这种现象称为 backtracking，一般要枚举所有情况就会用到 backtracking。</p>
<!-- hexo-inject:begin --><!-- hexo-inject:end --><p>下图解答树中黄线便是 backtracking。</p>
<p><img src="/2019/05/LeetCode中的Backtracking总结/jiedashu.gif" alt="解答树"></p>
<h2 id="基础模板"><a href="#基础模板" class="headerlink" title="基础模板"></a>基础模板</h2><h2 id="子集生成"><a href="#子集生成" class="headerlink" title="子集生成"></a>子集生成</h2><h3 id="无边界限制——-Basic-Subsets"><a href="#无边界限制——-Basic-Subsets" class="headerlink" title="无边界限制—— Basic Subsets"></a>无边界限制—— Basic Subsets</h3><ol>
<li>子集生成<strong>没有固定的边界条件</strong>，每一次递归调用，都要将当前 list 记录的子集添加进 res，当无法继续添加元素的时候，递归自动停止。</li>
<li>SubSet 题型子函数进行处理的部分 <strong>for 循环要从传递入的 start 开始</strong>（原因在 Combination Sum解释了）。</li>
</ol>
<h4 id="无重复元素的-Subsets"><a href="#无重复元素的-Subsets" class="headerlink" title="无重复元素的 Subsets"></a>无重复元素的 Subsets</h4><p><a href="https://leetcode.com/problems/subsets/" target="_blank" rel="noopener">78. Subsets</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        helper(res,<span class="keyword">new</span> ArrayList&lt;&gt;(),nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res,List&lt;Integer&gt; list, <span class="keyword">int</span>[] nums, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=start; i&lt;nums.length;i++) &#123;</span><br><span class="line">            list.add(nums[i]);</span><br><span class="line">            helper(res,list,nums,i+<span class="number">1</span>);</span><br><span class="line">            list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="有重复元素的-Subsets"><a href="#有重复元素的-Subsets" class="headerlink" title="有重复元素的 Subsets"></a>有重复元素的 Subsets</h4><p><a href="https://leetcode.com/problems/subsets-ii/" target="_blank" rel="noopener">90. Subsets II</a></p>
<p>为了避免重复的子集加入：</p>
<ol>
<li><p>我们要在主函数部分对nums 进行 sort<code>Arrays.sort(nums)</code></p>
</li>
<li><p>我们需要在子函数的处理部分添加一句判断语句：</p>
<p><code>if (i!=start &amp;&amp; nums[i] == nums[i-1]) continue;</code></p>
</li>
</ol>
<p>为了方便理解，我画了一棵解答树。红色框框为被判断语句过滤掉的内容。蓝色框框为对应start轮数加入 res 的子集（到达边界）。黑色是常规的 recursion 部分。</p>
<p><img src="/2019/05/LeetCode中的Backtracking总结/1.png" alt="解答树"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        helper(res,<span class="keyword">new</span> ArrayList&lt;&gt;(),nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; list, <span class="keyword">int</span>[] nums, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="初尝边界——Combination"><a href="#初尝边界——Combination" class="headerlink" title="初尝边界——Combination"></a>初尝边界——Combination</h3><h4 id="Basic-Combination"><a href="#Basic-Combination" class="headerlink" title="Basic Combination"></a>Basic Combination</h4><p><a href="https://leetcode.com/problems/combinations/" target="_blank" rel="noopener">77. Combinations</a></p>
<p>Given two integers <em>n</em> and <em>k</em>, return all possible combinations of <em>k</em>numbers out of 1 … <em>n</em></p>
<p><strong>主函数部分</strong></p>
<ol>
<li>通过题目给的函数主干，我们得知 return 的type，便在函数一开头进行 res 的初始化：</li>
</ol>
<p><code>&lt;List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</code></p>
<ol start="2">
<li><p>然后我们进行边界判定<code>if (n&lt;=n || k&lt;=n) return res;</code></p>
</li>
<li><p>书写需要传递进子函数的内容</p>
<ol>
<li>return的是 res，所以我们必然需要将 res 传递进入子函数，但是 return 的是<code>&lt;List&lt;List&lt;Integer&gt;&gt;</code>所以我们肯定还需要一个动态的<code>List&lt;Integer&gt; list</code></li>
<li>题目给我们的 n 和 k</li>
<li>指针 start，标记当前遍历到的位置</li>
</ol>
<p>综上可以写出 : <code>helper(res,new ArrayList&lt;&gt;(),n,k,1);</code></p>
</li>
</ol>
<p><strong>子函数（backtracking）部分</strong></p>
<ol>
<li><p>在这一题中，第一次有了边界条件，每个答案只能有 k 个元素组成，所以我们写成边界判断语句：</p>
<p><code>if(k==0) res.add(new ArrayList&lt;&gt;(list))</code>,注意要初始化<code>new ArrayList&lt;&gt;()</code>不能直接 add。</p>
</li>
<li><p>接下来遍历从start（注意不是从头，而是从 start）到 n所有数字，当前层加入一个数字后进行递归操作，因为我们的边界判断是<code>k=0</code>，所以每次递归我们都要将 k 减去1。start 指针指向 i+1(注意不是 start+1)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=start; i&lt;=n; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">            helper(res,list,n,k-<span class="number">1</span>,i+<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>因为 list 是一个动态数组，所以我们需要维系这个数组，返回到上一层，于是我们进行 backtracking 操作：</p>
<p><code>list.remove(list.size()-1);</code></p>
<p><strong>以下是完整的代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res =<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>( n&lt;=<span class="number">0</span> || k&lt;=<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        helper(res, <span class="keyword">new</span> ArrayList&lt;&gt;(), n, k, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; list, <span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=start; i&lt;=n; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">            helper(res,list,n,k-<span class="number">1</span>,i+<span class="number">1</span>);</span><br><span class="line">            list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="Combination-Sum"><a href="#Combination-Sum" class="headerlink" title="Combination Sum"></a>Combination Sum</h4><p><a href="https://leetcode.com/problems/combination-sum/" target="_blank" rel="noopener">39. Combination Sum</a></p>
<p>Given a <strong>set</strong> of candidate numbers (<code>candidates</code>) <strong>(without duplicates)</strong> and a target number (<code>target</code>), find all unique combinations in <code>candidates</code> where the candidate numbers sums to <code>target</code>.</p>
<p>The <strong>same</strong> repeated number may be chosen from <code>candidates</code> unlimited number of times.</p>
<ol>
<li><p>这一题和上一题的处理方式，数组 candidates对应 n，边界判断条件从 k 变成 target，这样的改变会有两种情况产生，递归的最后<code>target == 0</code>和<code>target&lt;0</code>,前者我们和上一题一样把 list 加入 res，后者我们直接 return 舍弃掉。</p>
</li>
<li><p>现在来看函数调用的部分：</p>
<ol>
<li><p>上一题我们对 k 的处理方式是每次调用都减去1，这一题中，我们的处理方式是<code>target-candidates[i]</code></p>
</li>
<li><p>原题中说到，允许一个数字使用很多遍，所以在这里，我们不需要<code>i+1</code>，我们直接把 <code>i</code>放入即可。(但注意，不是 start，允许一个数字使用多回，和允许答案中出现重复数组不是一回事，所以和之前的重复判断语句没有关系)。</p>
</li>
<li><p>还要注意，这里不能直接把 start 指针删掉是因为<strong>different sequences are counted as same combinations</strong>（区别于 Combination Sum IV）。这句话的意思是，[2,2,3],[2,3,2],[3,2,2]被看作是一样的。细心的话可以发现，这其实就是全排列，这也是为什么全排列的 for 每一次都是从0开始了。</p>
<p>综上<code>helper(res,candidates,list,target-candidates[i],i);</code></p>
</li>
</ol>
</li>
</ol>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(candidates==<span class="keyword">null</span> || candidates.length == <span class="number">0</span> || target&lt;=<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        helper(res, <span class="keyword">new</span> ArrayList&lt;&gt;(),candidates,target,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; list, <span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i&lt;candidates.length; i++) &#123;</span><br><span class="line">            list.add(candidates[i]);</span><br><span class="line">            helper(res,list,candidates,target-candidates[i],i);</span><br><span class="line">            list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Combination-Sum-II"><a href="#Combination-Sum-II" class="headerlink" title="Combination Sum II"></a>Combination Sum II</h4><p>这一题对上一题做出了如下两点改动，对应的我们也对代码做两点改动：</p>
<ol>
<li>给的数组 candidates 里有重复的数字出现，应对这个情况，我们的处理方式和 Subsets II 中一样，搬来判断语句： <code>if (i!=start &amp;&amp; nums[i] == nums[i-1]) continue;</code>和<code>Arrays.sort(candidates)</code></li>
<li>每个数组只允许用一次，那么我们就在调用的时候让 start 往后走一个位置即可：<code>i+1</code></li>
</ol>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">      Arrays.sort(candidates);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        helper(res, <span class="keyword">new</span> ArrayList&lt;&gt;(), candidates, target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; list, <span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=start; i &lt; candidates.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i!=start &amp;&amp; candidates[i] == candidates[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            list.add(candidates[i]);</span><br><span class="line">            helper(res,list,candidates,target-candidates[i],i+<span class="number">1</span>);</span><br><span class="line">            list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Combination-Sum-III"><a href="#Combination-Sum-III" class="headerlink" title="Combination Sum III"></a>Combination Sum III</h4><p>Find all possible combinations of <strong><em>k</em></strong> numbers(第一个边界条件 k) that add up to a number <strong><em>n</em></strong>（第二个边界条件约等于上一题的 target）, given that only numbers from 1 to 9(这个看做是需要遍历到数组，因为是1~9所以没有重复问题，不需要小砖块) can be used and each combination should be a unique set of numbers（只能用一次 i 要加1）.</p>
<p>这一题是Basic Combination和Combination Sum II的结合。通过上面我读题时候的备注，我们得知需要改两个地方：</p>
<ol>
<li><p>出口条件改动，一定要注意，只有当 n 和 k 都为0的时候才是满足要求的答案。但如果有一个小于0的话就直接 return 了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (k &lt;<span class="number">0</span> || n&lt;<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (k == <span class="number">0</span> &amp;&amp; n==<span class="number">0</span>) res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br></pre></td></tr></table></figure>
</li>
<li><p>k 和 n 都要变<code>helper(res,list,k-1,n-i,i+1);</code></p>
</li>
</ol>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum3(<span class="keyword">int</span> k, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        helper(res,<span class="keyword">new</span> ArrayList&lt;&gt;(),k,n,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; list, <span class="keyword">int</span> k, <span class="keyword">int</span> n, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &lt;<span class="number">0</span> || n&lt;<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> &amp;&amp; n==<span class="number">0</span>) res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i&lt;=<span class="number">9</span>; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">            helper(res,list,k-<span class="number">1</span>,n-i,i+<span class="number">1</span>);</span><br><span class="line">            list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Combination-Sum-IV"><a href="#Combination-Sum-IV" class="headerlink" title="Combination Sum IV"></a>Combination Sum IV</h4><h5 id="Basic-Recursion"><a href="#Basic-Recursion" class="headerlink" title="Basic Recursion"></a>Basic Recursion</h5><p><strong>Note that different sequences are counted as different combinations.</strong></p>
<p>一定要注意题目中的这句话，这句话让我们不需要使用start 指针，每次递归遍历都是从0开始，由此我们写出最基本的递归式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> helper (nums,target);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(target&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(target ==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (nums[i] &lt;= target)&#123;</span><br><span class="line">          res += helper(nums,target-nums[i]);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后跑一跑发现<strong>Time Limit Exceeded</strong>了，递归发生这种情况，肯定是有的 test case 过分庞大，导致整个解答树都很冗余，进行了大量的重复的计算，怎么办呢？*<em>memorization *</em>的思想可以帮助你。</p>
<h5 id="Memorization"><a href="#Memorization" class="headerlink" title="Memorization"></a>Memorization</h5><p>所谓memorization 就是我们用一个 HashMap 把我们算过的东西存起来，下次在算之前先看我们之前算没算过，算过了 get 一下就阔以节省很多的时间啦。</p>
<p>那在这一题里算过的东西是什么呢？是<strong>这些数组里的数字有多少种方式可以组成当前的 target</strong>，也就是<strong>原问题的一个子问题</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length ==<span class="number">0</span> || target &lt;<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;       </span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(target)) <span class="keyword">return</span> map.get(target);      </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            res+=combinationSum4(nums,target-num);            </span><br><span class="line">        &#125;</span><br><span class="line">        map.put(target,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Dynamic-Programming"><a href="#Dynamic-Programming" class="headerlink" title="Dynamic Programming"></a>Dynamic Programming</h5><p>既然我们使用Memorization 就是为了解决大量的重叠子问题，并且我们已知局部最优就是全局最优，那么这个问题就可以使用最终形态 DP 来解。</p>
<p>在 Memorization 的方法里，我们提到，重叠的子问题是这些数组里的数字有多少种方式可以组成当前的 target，那么舍弃掉 Map，我们用一个一维数组<code>dp[target]</code>来代替，由此，我们写出转移方程式：<br>$$<br>when;;;i-nums[j]\geq0\<br>dp[i] =dp[i]+dp[i-nums[j]]\<br>$$</p>
<p>因为我们必然可以在数组中找到<code>nums[j]</code>，所以我们将有多种办法组成i的问题转化为子问题：我们有多少种办法组成<code>i-nums[j]</code>,这个子问题答案我们存在了<code>dp[i-nums[j]]</code>。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;dp.length;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;nums.length;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i-nums[j]&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i] +=dp[i-nums[j]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Follow-Up"><a href="#Follow-Up" class="headerlink" title="Follow Up"></a>Follow Up</h5><blockquote>
<p>What if negative numbers are allowed in the given array?<br>How does it change the problem?<br>What limitation we need to add to the question to allow negative numbers?</p>
</blockquote>
<p>In order to allow negative integers, the length of the combination sum needs to be restricted, or the search will not stop. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Map&lt;Integer,Integer&gt;&gt; map2 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">helper2</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> len, <span class="keyword">int</span> target, <span class="keyword">int</span> MaxLen)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (  len &gt; MaxLen  ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ( map2.containsKey(target) &amp;&amp; map2.get(target).containsKey(len)) &#123; </span><br><span class="line">        	<span class="keyword">return</span> map2.get(target).get(len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( target == <span class="number">0</span> )   count++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">            count+= helper2(nums, len+<span class="number">1</span>, target-num, MaxLen);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( ! map2.containsKey(target) ) map2.put(target, <span class="keyword">new</span> HashMap&lt;Integer,Integer&gt;());</span><br><span class="line">        Map&lt;Integer,Integer&gt; mem = map2.get(target);</span><br><span class="line">        mem.put(len, count);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">combinationSum42</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> MaxLen)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length ==<span class="number">0</span> || MaxLen &lt;= <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        map2 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> helper2(nums, <span class="number">0</span>,target, MaxLen);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Factor-Combinations"><a href="#Factor-Combinations" class="headerlink" title="Factor Combinations"></a>Factor Combinations</h4></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Dubliner</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2019/05/LeetCode中的Backtracking总结/">http://yoursite.com/2019/05/LeetCode中的Backtracking总结/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/LeetCode/">LeetCode</a><a class="post-meta__tags" href="/tags/Backtracking/">Backtracking</a></div><nav id="pagination"></nav></div></div><footer class="footer-bg" style="background-image: url(/bg.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2019 By Dubliner</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script><!-- hexo-inject:begin --><!-- hexo-inject:end --></body></html>