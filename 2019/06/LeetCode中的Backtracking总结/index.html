<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="LeetCode 中的 Backtracking 总结"><meta name="keywords" content="LeetCode分类总结"><meta name="author" content="Dubliner"><meta name="copyright" content="Dubliner"><title>LeetCode 中的 Backtracking 总结 | Dubliner</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script><!-- hexo-inject:begin --><!-- hexo-inject:end -->var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><!-- hexo-inject:begin --><!-- hexo-inject:end --></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#基础模板"><span class="toc-number">1.</span> <span class="toc-text">基础模板</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#子集生成"><span class="toc-number">2.</span> <span class="toc-text">子集生成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#无边界限制——-Basic-Subsets"><span class="toc-number">2.1.</span> <span class="toc-text">无边界限制—— Basic Subsets</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#无重复元素的-Subsets"><span class="toc-number">2.1.1.</span> <span class="toc-text">无重复元素的 Subsets</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#有重复元素的-Subsets"><span class="toc-number">2.1.2.</span> <span class="toc-text">有重复元素的 Subsets</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#初尝边界——Combination"><span class="toc-number">2.2.</span> <span class="toc-text">初尝边界——Combination</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Basic-Combination"><span class="toc-number">2.2.1.</span> <span class="toc-text">Basic Combination</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Combination-Sum"><span class="toc-number">2.2.2.</span> <span class="toc-text">Combination Sum</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Combination-Sum-II"><span class="toc-number">2.2.3.</span> <span class="toc-text">Combination Sum II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Combination-Sum-III"><span class="toc-number">2.2.4.</span> <span class="toc-text">Combination Sum III</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Combination-Sum-IV"><span class="toc-number">2.2.5.</span> <span class="toc-text">Combination Sum IV</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Basic-Recursion"><span class="toc-number">2.2.5.1.</span> <span class="toc-text">Basic Recursion</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Memorization"><span class="toc-number">2.2.5.2.</span> <span class="toc-text">Memorization</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Dynamic-Programming"><span class="toc-number">2.2.5.3.</span> <span class="toc-text">Dynamic Programming</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Follow-Up"><span class="toc-number">2.2.5.4.</span> <span class="toc-text">Follow Up</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Factor-Combinations"><span class="toc-number">2.2.6.</span> <span class="toc-text">Factor Combinations</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#全排列"><span class="toc-number">3.</span> <span class="toc-text">全排列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Basic-Permuation"><span class="toc-number">3.1.</span> <span class="toc-text">Basic Permuation</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#生成1-n的全排列"><span class="toc-number">3.1.1.</span> <span class="toc-text">生成1~n的全排列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#生成可重集的排列"><span class="toc-number">3.1.2.</span> <span class="toc-text">生成可重集的排列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#下一个排列"><span class="toc-number">3.2.</span> <span class="toc-text">下一个排列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#下一个排列是什么"><span class="toc-number">3.2.1.</span> <span class="toc-text">下一个排列是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#第-N-个排列是什么"><span class="toc-number">3.2.2.</span> <span class="toc-text">第 N 个排列是什么</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#和-String-相关的枚举"><span class="toc-number">4.</span> <span class="toc-text">和 String 相关的枚举</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#StringBuilder-的应用"><span class="toc-number">4.1.</span> <span class="toc-text">StringBuilder 的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Letter-Combinations-of-a-Phone-Number"><span class="toc-number">4.1.1.</span> <span class="toc-text">Letter Combinations of a Phone Number</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Generalized-Abbreviation"><span class="toc-number">4.1.2.</span> <span class="toc-text">Generalized Abbreviation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Restore-IP-Addresses"><span class="toc-number">4.1.3.</span> <span class="toc-text">Restore IP Addresses</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Expression-Add-Operators"><span class="toc-number">4.1.4.</span> <span class="toc-text">Expression Add Operators</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Word-Break-II"><span class="toc-number">4.1.5.</span> <span class="toc-text">Word Break II</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其他"><span class="toc-number">4.2.</span> <span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Word-Pattern"><span class="toc-number">4.2.1.</span> <span class="toc-text">Word Pattern</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#与-DFS-BFS-的水乳交融"><span class="toc-number">5.</span> <span class="toc-text">与 DFS/BFS 的水乳交融</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Android-Unlock-Patterns"><span class="toc-number">5.1.</span> <span class="toc-text">Android Unlock Patterns</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/head.jpg"></div><div class="author-info__name text-center">Dubliner</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">7</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">4</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">11</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/bg.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Dubliner</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">主页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span></div><div id="post-info"><div id="post-title">LeetCode 中的 Backtracking 总结</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-06-21</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/LeetCode/">LeetCode</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/LeetCode/Algorithm/">Algorithm</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/LeetCode/Algorithm/Backtracking/">Backtracking</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>递归函数不再调用它本身，而是返回上一层调用，这种现象称为 backtracking，一般要枚举所有情况就会用到 backtracking。</p>
<!-- hexo-inject:begin --><!-- hexo-inject:end --><p>下图解答树中黄线便是 backtracking。</p>
<p><img src="/2019/06/LeetCode中的Backtracking总结/jiedashu.gif" alt="解答树"></p>
<h2 id="基础模板"><a href="#基础模板" class="headerlink" title="基础模板"></a>基础模板</h2><p>该模板以Basic Combination为例</p>
<p><img src="/2019/06/LeetCode中的Backtracking总结/2.png" alt="backtracking模板"></p>
<a id="more"></a>
<h2 id="子集生成"><a href="#子集生成" class="headerlink" title="子集生成"></a>子集生成</h2><h3 id="无边界限制——-Basic-Subsets"><a href="#无边界限制——-Basic-Subsets" class="headerlink" title="无边界限制—— Basic Subsets"></a>无边界限制—— Basic Subsets</h3><ol>
<li>子集生成<strong>没有固定的边界条件</strong>，每一次递归调用，都要将当前 list 记录的子集添加进 res，当无法继续添加元素的时候，递归自动停止。</li>
<li>SubSet 题型子函数进行处理的部分 <strong>for 循环要从传递入的 start 开始</strong>（原因在 Combination Sum解释了）。</li>
</ol>
<h4 id="无重复元素的-Subsets"><a href="#无重复元素的-Subsets" class="headerlink" title="无重复元素的 Subsets"></a>无重复元素的 Subsets</h4><p><a href="https://leetcode.com/problems/subsets/" target="_blank" rel="noopener">78. Subsets</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        helper(res,<span class="keyword">new</span> ArrayList&lt;&gt;(),nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res,List&lt;Integer&gt; list, <span class="keyword">int</span>[] nums, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=start; i&lt;nums.length;i++) &#123;</span><br><span class="line">            list.add(nums[i]);</span><br><span class="line">            helper(res,list,nums,i+<span class="number">1</span>);</span><br><span class="line">            list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="有重复元素的-Subsets"><a href="#有重复元素的-Subsets" class="headerlink" title="有重复元素的 Subsets"></a>有重复元素的 Subsets</h4><p><a href="https://leetcode.com/problems/subsets-ii/" target="_blank" rel="noopener">90. Subsets II</a></p>
<p>为了避免重复的子集加入：</p>
<ol>
<li><p>我们要在主函数部分对nums 进行 sort<code>Arrays.sort(nums)</code></p>
</li>
<li><p>我们需要在子函数的处理部分添加一句判断语句：</p>
<p><code>if (i!=start &amp;&amp; nums[i] == nums[i-1]) continue;</code></p>
</li>
</ol>
<p>为了方便理解，我画了一棵解答树。红色框框为被判断语句过滤掉的内容。蓝色框框为对应start轮数加入 res 的子集（到达边界）。黑色是常规的 recursion 部分。</p>
<p><img src="/2019/06/LeetCode中的Backtracking总结/1.png" alt="解答树"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        helper(res,<span class="keyword">new</span> ArrayList&lt;&gt;(),nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; list, <span class="keyword">int</span>[] nums, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i&lt;nums.length;i++) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (i &gt; start &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            list.add(nums[i]);</span><br><span class="line">            helper(res, list, nums, i+<span class="number">1</span>);</span><br><span class="line">            list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">          </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="初尝边界——Combination"><a href="#初尝边界——Combination" class="headerlink" title="初尝边界——Combination"></a>初尝边界——Combination</h3><h4 id="Basic-Combination"><a href="#Basic-Combination" class="headerlink" title="Basic Combination"></a>Basic Combination</h4><p><a href="https://leetcode.com/problems/combinations/" target="_blank" rel="noopener">77. Combinations</a></p>
<p>Given two integers <em>n</em> and <em>k</em>, return all possible combinations of <em>k</em>numbers out of 1 … <em>n</em></p>
<p><strong>主函数部分</strong></p>
<ol>
<li>通过题目给的函数主干，我们得知 return 的type，便在函数一开头进行 res 的初始化：</li>
</ol>
<p><code>&lt;List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</code></p>
<ol>
<li><p>然后我们进行边界判定<code>if (n&lt;=n || k&lt;=n) return res;</code></p>
</li>
<li><p>书写需要传递进子函数的内容</p>
<ol>
<li>return的是 res，所以我们必然需要将 res 传递进入子函数，但是 return 的是<code>&lt;List&lt;List&lt;Integer&gt;&gt;</code>所以我们肯定还需要一个动态的<code>List&lt;Integer&gt; list</code></li>
<li>题目给我们的 n 和 k</li>
<li>指针 start，标记当前遍历到的位置</li>
</ol>
<p>综上可以写出 : <code>helper(res,new ArrayList&lt;&gt;(),n,k,1);</code></p>
</li>
</ol>
<p><strong>子函数（backtracking）部分</strong></p>
<ol>
<li><p>在这一题中，第一次有了边界条件，每个答案只能有 k 个元素组成，所以我们写成边界判断语句：</p>
<p><code>if(k==0) res.add(new ArrayList&lt;&gt;(list))</code>,注意要初始化<code>new ArrayList&lt;&gt;()</code>不能直接 add。</p>
</li>
<li><p>接下来遍历从start（注意不是从头，而是从 start）到 n所有数字，当前层加入一个数字后进行递归操作，因为我们的边界判断是<code>k=0</code>，所以每次递归我们都要将 k 减去1。start 指针指向 i+1(注意不是 start+1)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=start; i&lt;=n; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">            helper(res,list,n,k-<span class="number">1</span>,i+<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>因为 list 是一个动态数组，所以我们需要维系这个数组，返回到上一层，于是我们进行 backtracking 操作：</p>
<p><code>list.remove(list.size()-1);</code></p>
</li>
</ol>
<p><strong>以下是完整的代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res =<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>( n&lt;=<span class="number">0</span> || k&lt;=<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        helper(res, <span class="keyword">new</span> ArrayList&lt;&gt;(), n, k, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; list, <span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=start; i&lt;=n; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">            helper(res,list,n,k-<span class="number">1</span>,i+<span class="number">1</span>);</span><br><span class="line">            list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Combination-Sum"><a href="#Combination-Sum" class="headerlink" title="Combination Sum"></a>Combination Sum</h4><p><a href="https://leetcode.com/problems/combination-sum/" target="_blank" rel="noopener">39. Combination Sum</a></p>
<p>Given a <strong>set</strong> of candidate numbers (<code>candidates</code>) <strong>(without duplicates)</strong> and a target number (<code>target</code>), find all unique combinations in <code>candidates</code> where the candidate numbers sums to <code>target</code>.</p>
<p>The <strong>same</strong> repeated number may be chosen from <code>candidates</code> unlimited number of times.</p>
<ol>
<li><p>这一题和上一题的处理方式，数组 candidates对应 n，边界判断条件从 k 变成 target，这样的改变会有两种情况产生，递归的最后<code>target == 0</code>和<code>target&lt;0</code>,前者我们和上一题一样把 list 加入 res，后者我们直接 return 舍弃掉。</p>
</li>
<li><p>现在来看函数调用的部分：</p>
<ol>
<li><p>上一题我们对 k 的处理方式是每次调用都减去1，这一题中，我们的处理方式是<code>target-candidates[i]</code></p>
</li>
<li><p>原题中说到，允许一个数字使用很多遍，所以在这里，我们不需要<code>i+1</code>，我们直接把 <code>i</code>放入即可。(但注意，不是 start，允许一个数字使用多回，和允许答案中出现重复数组不是一回事，所以和之前的重复判断语句没有关系)。</p>
</li>
<li><p>还要注意，这里不能直接把 start 指针删掉是因为<strong>different sequences are counted as same combinations</strong>（区别于 Combination Sum IV）。这句话的意思是，[2,2,3],[2,3,2],[3,2,2]被看作是一样的。细心的话可以发现，这其实就是全排列，这也是为什么全排列的 for 每一次都是从0开始了。</p>
<p>综上<code>helper(res,candidates,list,target-candidates[i],i);</code></p>
</li>
</ol>
</li>
</ol>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(candidates==<span class="keyword">null</span> || candidates.length == <span class="number">0</span> || target&lt;=<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        helper(res, <span class="keyword">new</span> ArrayList&lt;&gt;(),candidates,target,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; list, <span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i&lt;candidates.length; i++) &#123;</span><br><span class="line">            list.add(candidates[i]);</span><br><span class="line">            helper(res,list,candidates,target-candidates[i],i);</span><br><span class="line">            list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Combination-Sum-II"><a href="#Combination-Sum-II" class="headerlink" title="Combination Sum II"></a>Combination Sum II</h4><p>这一题对上一题做出了如下两点改动，对应的我们也对代码做两点改动：</p>
<ol>
<li>给的数组 candidates 里有重复的数字出现，应对这个情况，我们的处理方式和 Subsets II 中一样，搬来判断语句： <code>if (i!=start &amp;&amp; nums[i] == nums[i-1]) continue;</code>和<code>Arrays.sort(candidates)</code></li>
<li>每个数组只允许用一次，那么我们就在调用的时候让 start 往后走一个位置即可：<code>i+1</code></li>
</ol>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">      Arrays.sort(candidates);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        helper(res, <span class="keyword">new</span> ArrayList&lt;&gt;(), candidates, target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; list, <span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=start; i &lt; candidates.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i!=start &amp;&amp; candidates[i] == candidates[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            list.add(candidates[i]);</span><br><span class="line">            helper(res,list,candidates,target-candidates[i],i+<span class="number">1</span>);</span><br><span class="line">            list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Combination-Sum-III"><a href="#Combination-Sum-III" class="headerlink" title="Combination Sum III"></a>Combination Sum III</h4><p>Find all possible combinations of <strong><em>k</em></strong> numbers(第一个边界条件 k) that add up to a number <strong><em>n</em></strong>（第二个边界条件约等于上一题的 target）, given that only numbers from 1 to 9(这个看做是需要遍历到数组，因为是1~9所以没有重复问题，不需要小砖块) can be used and each combination should be a unique set of numbers（只能用一次 i 要加1）.</p>
<p>这一题是Basic Combination和Combination Sum II的结合。通过上面我读题时候的备注，我们得知需要改两个地方：</p>
<ol>
<li><p>出口条件改动，一定要注意，只有当 n 和 k 都为0的时候才是满足要求的答案。但如果有一个小于0的话就直接 return 了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (k &lt;<span class="number">0</span> || n&lt;<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (k == <span class="number">0</span> &amp;&amp; n==<span class="number">0</span>) res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br></pre></td></tr></table></figure>
</li>
<li><p>k 和 n 都要变<code>helper(res,list,k-1,n-i,i+1);</code></p>
</li>
</ol>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum3(<span class="keyword">int</span> k, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        helper(res,<span class="keyword">new</span> ArrayList&lt;&gt;(),k,n,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; list, <span class="keyword">int</span> k, <span class="keyword">int</span> n, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &lt;<span class="number">0</span> || n&lt;<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> &amp;&amp; n==<span class="number">0</span>) res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i&lt;=<span class="number">9</span>; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">            helper(res,list,k-<span class="number">1</span>,n-i,i+<span class="number">1</span>);</span><br><span class="line">            list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Combination-Sum-IV"><a href="#Combination-Sum-IV" class="headerlink" title="Combination Sum IV"></a>Combination Sum IV</h4><h5 id="Basic-Recursion"><a href="#Basic-Recursion" class="headerlink" title="Basic Recursion"></a>Basic Recursion</h5><p><strong>Note that different sequences are counted as different combinations.</strong></p>
<p>一定要注意题目中的这句话，这句话让我们不需要使用start 指针，每次递归遍历都是从0开始，由此我们写出最基本的递归式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> helper (nums,target);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(target&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(target ==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (nums[i] &lt;= target)&#123;</span><br><span class="line">          res += helper(nums,target-nums[i]);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后跑一跑发现<strong>Time Limit Exceeded</strong>了，递归发生这种情况，肯定是有的 test case 过分庞大，导致整个解答树都很冗余，进行了大量的重复的计算，怎么办呢？<strong>memorization </strong>的思想可以帮助你。</p>
<h5 id="Memorization"><a href="#Memorization" class="headerlink" title="Memorization"></a>Memorization</h5><p>所谓memorization 就是我们用一个 HashMap 把我们算过的东西存起来，下次在算之前先看我们之前算没算过，算过了 get 一下就阔以节省很多的时间啦。</p>
<p>那在这一题里算过的东西是什么呢？是<strong>这些数组里的数字有多少种方式可以组成当前的 target</strong>，也就是<strong>原问题的一个子问题</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length ==<span class="number">0</span> || target &lt;<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;       </span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(target)) <span class="keyword">return</span> map.get(target);      </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            res+=combinationSum4(nums,target-num);            </span><br><span class="line">        &#125;</span><br><span class="line">        map.put(target,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Dynamic-Programming"><a href="#Dynamic-Programming" class="headerlink" title="Dynamic Programming"></a>Dynamic Programming</h5><p>既然我们使用Memorization 就是为了解决大量的重叠子问题，并且我们已知局部最优就是全局最优，那么这个问题就可以使用最终形态 DP 来解。</p>
<p>在 Memorization 的方法里，我们提到，重叠的子问题是这些数组里的数字有多少种方式可以组成当前的 target，那么舍弃掉 Map，我们用一个一维数组<code>dp[target]</code>来代替，由此，我们写出转移方程式：</p>
<script type="math/tex; mode=display">dp[i] =dp[i]+dp[i-nums[j]]</script><p>因为我们必然可以在数组中找到<code>nums[j]</code>，所以我们将有多种办法组成i的问题转化为子问题：我们有多少种办法组成<code>i-nums[j]</code>,这个子问题答案我们存在了<code>dp[i-nums[j]]</code>。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;dp.length;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;nums.length;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i-nums[j]&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i] +=dp[i-nums[j]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Follow-Up"><a href="#Follow-Up" class="headerlink" title="Follow Up"></a>Follow Up</h5><blockquote>
<p>What if negative numbers are allowed in the given array?<br>How does it change the problem?<br>What limitation we need to add to the question to allow negative numbers?</p>
</blockquote>
<p>In order to allow negative integers, the length of the combination sum needs to be restricted, or the search will not stop. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Map&lt;Integer,Integer&gt;&gt; map2 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">helper2</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> len, <span class="keyword">int</span> target, <span class="keyword">int</span> MaxLen)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (  len &gt; MaxLen  ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ( map2.containsKey(target) &amp;&amp; map2.get(target).containsKey(len)) &#123; </span><br><span class="line">        	<span class="keyword">return</span> map2.get(target).get(len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( target == <span class="number">0</span> )   count++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">            count+= helper2(nums, len+<span class="number">1</span>, target-num, MaxLen);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( ! map2.containsKey(target) ) map2.put(target, <span class="keyword">new</span> HashMap&lt;Integer,Integer&gt;());</span><br><span class="line">        Map&lt;Integer,Integer&gt; mem = map2.get(target);</span><br><span class="line">        mem.put(len, count);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">combinationSum42</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> MaxLen)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length ==<span class="number">0</span> || MaxLen &lt;= <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        map2 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> helper2(nums, <span class="number">0</span>,target, MaxLen);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="Factor-Combinations"><a href="#Factor-Combinations" class="headerlink" title="Factor Combinations"></a>Factor Combinations</h4><p><a href="https://leetcode.com/problems/factor-combinations/" target="_blank" rel="noopener">254. Factor Combinations</a></p>
<blockquote>
<p>Numbers can be regarded as product of its factors. </p>
<p>Example:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8 = 2 x 2 x 2;</span><br><span class="line">  = 2 x 4.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>You may assume that n is always positive.<br>Factors should be greater than 1 and less than n.</p>
</blockquote>
<ol>
<li>从题目中我们可以知道，1~n 是我们要遍历的数组，n 作为 target 也是边界出口。</li>
<li>同时，因为任何数乘以1都是自己，所以这道题需要排除1和自己，start指针从2开始。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; getFactors(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        helper(res, <span class="keyword">new</span> ArrayList&lt;&gt;(),n,<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; list, <span class="keyword">int</span> n, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list.size() &gt; <span class="number">1</span>) res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start; i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">                list.add(i);</span><br><span class="line">                helper(res, list, n/i, i);</span><br><span class="line">                list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><h3 id="Basic-Permuation"><a href="#Basic-Permuation" class="headerlink" title="Basic Permuation"></a>Basic Permuation</h3><h4 id="生成1-n的全排列"><a href="#生成1-n的全排列" class="headerlink" title="生成1~n的全排列"></a>生成1~n的全排列</h4><p><a href="https://leetcode.com/problems/permutations/" target="_blank" rel="noopener">46. Permutations</a></p>
<ol>
<li>在 Permutation 中，start 指针的作用是用来记录我们已经加入几个数字了，为了最后作为边界条件判定，而不是为了 for 的遍历。我们甚至可以不添加这个 start 指针，直接用<code>list.size()==nums.length</code>作为边界条件的判断。下一小题中我将做出示范。</li>
<li>因为每个位置上每个数字都可以出现，先后顺序不同就是不同的子答案，所以 for 循环是从头开始的。</li>
<li>因此，我们需要判断语句<code>if(list.contains(nums[i]))</code>,来判断这个数字能不能加入到 list 中作为查重判断，这和子集的查重显然是不一样的。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        helper(res, <span class="keyword">new</span> ArrayList&lt;&gt;(), nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(List&lt;List&lt;Integer&gt;&gt;res, List&lt;Integer&gt; list, <span class="keyword">int</span>[] nums, <span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (number == nums.length) res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(list.contains(nums[i])) <span class="keyword">continue</span>;</span><br><span class="line">                list.add(nums[i]);</span><br><span class="line">                helper(res,list,nums,number+<span class="number">1</span>);</span><br><span class="line">                list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="生成可重集的排列"><a href="#生成可重集的排列" class="headerlink" title="生成可重集的排列"></a>生成可重集的排列</h4><p><a href="https://leetcode.com/problems/permutations-ii/" target="_blank" rel="noopener">47. Permutations II</a></p>
<p>和 SubSet 是镜像的问题，此时数组中存在重复的数字。我们需要进行两次判断：</p>
<ol>
<li><p>建立 boolean[]数组判断当前数是否已经被加过。这个剪枝类似于上一题中的 <code>list.contains ()</code>但因为这里有重复的数字了，我们不能用简单的 <code>list.contains()</code>来判断了，程序不知道到底是哪个2已经加过了。</p>
</li>
<li><p><code>i&gt;0 &amp;&amp; nums[i] == nums[i-1] &amp;&amp; !used[i-1]</code>这里的前一个数visited值为0，并不代表前一个数字没有被处理过，<strong>而是递归结束后恢复状态时将visited值重置为0了</strong>。</p>
</li>
</ol>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">         Arrays.sort(nums);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        helper(res, <span class="keyword">new</span> ArrayList&lt;&gt;(),nums, <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length]);</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; list, <span class="keyword">int</span>[] nums, <span class="keyword">boolean</span>[] used)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (list.size() == nums.length) res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">      </span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(used[i] || i&gt;<span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>] &amp;&amp; !used[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                used[i] =<span class="keyword">true</span>;</span><br><span class="line">            list.add(nums[i]);</span><br><span class="line">            helper(res,list,nums,used);</span><br><span class="line">            list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">            used[i] = <span class="keyword">false</span>;</span><br><span class="line">         &#125;           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="下一个排列"><a href="#下一个排列" class="headerlink" title="下一个排列"></a>下一个排列</h3><p>这组题更像是找规律的题目。</p>
<h4 id="下一个排列是什么"><a href="#下一个排列是什么" class="headerlink" title="下一个排列是什么"></a>下一个排列是什么</h4><p><a href="https://leetcode.com/problems/next-permutation/" target="_blank" rel="noopener">31. Next Permutation</a></p>
<p><strong>情况一</strong>：如果给定数组是降序，则说明是全排列的最后一种情况，则下一个排列就是最初始情况。</p>
<script type="math/tex; mode=display">3, 2, 1 ->1,2,3</script><p><strong>情况二</strong>：假设我们有如下序列</p>
<p>1         2　　7　　4　　3　　1</p>
<p>则下一个排列为：</p>
<p>1　　3　　1　　2　　4　　7</p>
<p>Step1：从序列末尾向前，找到第一个非递增数字，在这里是2。</p>
<p>1　　2　　7　　4　　3　　1</p>
<p>​          ^</p>
<p>Step2：再一次从序列末尾向前遍历，找到第一个比2大的数字，在这里是3。</p>
<p>1　　2　　7　　4　　3　　1</p>
<p>​                                        ^</p>
<p>Step3：交换这两个数字，在这里就是交换2和3。</p>
<p>1　　3　　7　　4　　2　　1</p>
<p>​          ^                            ^</p>
<p>Step4: 将3后的数字倒置即可。</p>
<p>1　　3　　1　　2　　4　　7</p>
<p>​                    ^        ^        ^        ^</p>
<p>这一题需要特别注意边界的判断：</p>
<p><code>while(i&gt;=0 &amp;&amp; nums[i]&gt;=nums[i+1]) i--;</code></p>
<p><code>while(j&gt;=0 &amp;&amp; nums[j]&lt;=nums[i]) j--;</code></p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums ==<span class="keyword">null</span> || nums.length ==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> i = nums.length -<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; nums[i]&gt;=nums[i+<span class="number">1</span>]) i--;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; nums[j]&lt;=nums[i]) j--;</span><br><span class="line">        swap(nums,i,j);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(nums,i+<span class="number">1</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] =temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j) &#123;</span><br><span class="line">            swap(nums,i++,j--);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="第-N-个排列是什么"><a href="#第-N-个排列是什么" class="headerlink" title="第 N 个排列是什么"></a>第 N 个排列是什么</h4><p><a href="https://leetcode.com/problems/permutation-sequence/" target="_blank" rel="noopener">60. Permutation Sequence</a></p>
<p><a href="https://www.cnblogs.com/grandyang/p/4358678.html" target="_blank" rel="noopener">以下解法copy 自 grandyang 的博客</a></p>
<p>首先我们要知道当n = 3时，其排列组合共有3! = 6种，当n = 4时，其排列组合共有4! = 24种，我们就以n = 4, k = 17的情况来分析，所有排列组合情况如下：</p>
<p>1234<br>1243<br>1324<br>1342<br>1423<br>1432</p>
<p>2134<br>2143<br>2314<br>2341<br>2413<br>2431</p>
<p>3124<br>3142<br>3214<br>3241<br>3412    &lt;—- k = 17<br>3421</p>
<p>4123<br>4132<br>4213<br>4231<br>4312<br>4321</p>
<p>我们可以发现，每一位上1,2,3,4分别都出现了6次，当最高位上的数字确定了，第二高位每个数字都出现了2次，当第二高位也确定了，第三高位上的数字都只出现了1次，当第三高位确定了，那么第四高位上的数字也只能出现一次，下面我们来看k = 17这种情况的每位数字如何确定，由于k = 17是转化为数组下标为16：</p>
<p>最高位可取1,2,3,4中的一个，每个数字出现3！= 6次（因为当最高位确定了，后面三位可以任意排列，所以是3！，那么最高位的数字就会重复3！次），所以k = 16的第一位数字的下标为16 / 6 = 2，在 “1234” 中即3被取出。这里我们的k是要求的坐标为k的全排列序列，我们定义 k’ 为当最高位确定后，要求的全排序列在新范围中的位置，同理，k’’ 为当第二高为确定后，所要求的全排列序列在新范围中的位置，以此类推，下面来具体看看：</p>
<p>第二位此时从1,2,4中取一个，k = 16，则此时的 k’ = 16 % (3!) = 4，注意思考这里为何要取余，如果对这24个数以6个一组来分，那么k=16这个位置就是在第三组（k/6 = 2）中的第五个（k%6 = 4）数字。如下所示，而剩下的每个数字出现2！= 2次，所以第二数字的下标为4 / 2 = 2，在 “124” 中即4被取出。</p>
<p>3124<br>3142<br>3214<br>3241<br>3412    &lt;—- k’ = 4<br>3421</p>
<p>第三位此时从1,2中去一个，k’ = 4，则此时的k’’ = 4 % (2!) = 0，如下所示，而剩下的每个数字出现1！= 1次，所以第三个数字的下标为 0 / 1 = 0，在 “12” 中即1被取出。</p>
<p>3412     &lt;—- k’’ = 0<br>3421</p>
<p>第四位是从2中取一个，k’’ = 0，则此时的k’’’ = 0 % (1!) = 0，如下所示，而剩下的每个数字出现0！= 1次，所以第四个数字的下标为0 / 1= 0，在 “2” 中即2被取出。</p>
<p>3412 &lt;—- k’’’ = 0</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] m = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        m[<span class="number">0</span>] =<span class="number">1</span>;</span><br><span class="line">        List&lt;Integer&gt; num = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        StringBuilder sb =<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sum =<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i &lt;=n; i++) &#123;</span><br><span class="line">            sum*=i;</span><br><span class="line">            m[i] = sum;</span><br><span class="line">            num.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        k--;       </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = k/m[n-i];</span><br><span class="line">            sb.append(String.valueOf(num.get(index)));</span><br><span class="line">            num.remove(index);</span><br><span class="line">            k-=m[n-i]*index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="和-String-相关的枚举"><a href="#和-String-相关的枚举" class="headerlink" title="和 String 相关的枚举"></a>和 String 相关的枚举</h2><h3 id="StringBuilder-的应用"><a href="#StringBuilder-的应用" class="headerlink" title="StringBuilder 的应用"></a>StringBuilder 的应用</h3><p>前面的题目，我们多用动态数组 ArrayList来存储每一个枚举结果，再通过出口条件加入到 res 中去，但在 String 的题目中，我们多用 StringBuilder 来存储，最后加入，之所以不使用 String是因为String 并不是动态的，每次递归都建立了一个新的 String。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">存储方式</th>
<th style="text-align:center">Backtracking 方式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Builder</td>
<td style="text-align:center">ArrayList</td>
<td style="text-align:center">list.remove(list.length()-1)</td>
</tr>
<tr>
<td style="text-align:center">String</td>
<td style="text-align:center">StringBuilder</td>
<td style="text-align:center">stringbuilder.setLength(oldLength)</td>
</tr>
</tbody>
</table>
</div>
<p>因为往往我们加入 StringBuilder的都不止一个字符，所以我们会在改变 sb 前用一个标量记录stringbuilder 的长度，方便还原。</p>
<h4 id="Letter-Combinations-of-a-Phone-Number"><a href="#Letter-Combinations-of-a-Phone-Number" class="headerlink" title="Letter Combinations of a Phone Number"></a>Letter Combinations of a Phone Number</h4><p><a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">17. Letter Combinations of a Phone Number</a></p>
<p>这一题的本质还是 Combination。我们将 digit的长度看成每个加入 res 的 String 的要求长度。这样我们就可以得知出口条件是<code>start == digit.length()</code>，在这里 start 是遍历 digit 的指针。</p>
<p>和之前题目的唯一差别只是之前每一次递归调用 for 循环的数组是同一个，但在这里，每一次递归调用我们遍历的都是当前数字对应的那个 String。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    String[] dic = &#123;<span class="string">""</span>, <span class="string">""</span>, <span class="string">"abc"</span>, <span class="string">"def"</span>, <span class="string">"ghi"</span>, <span class="string">"jkl"</span>, <span class="string">"mno"</span>, <span class="string">"pqrs"</span>, <span class="string">"tuv"</span>, <span class="string">"wxyz"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (digits == <span class="keyword">null</span> || digits.length() == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        helper(res, <span class="keyword">new</span> StringBuilder(), digits, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(List&lt;String&gt; res, StringBuilder sb, String digits, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == digits.length()) res.add(sb.toString());</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> index = digits.charAt(start) - <span class="string">'0'</span>;</span><br><span class="line">            String s = dic[index];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">                sb.append(c);</span><br><span class="line">                helper(res, sb, digits, start + <span class="number">1</span>);</span><br><span class="line">                sb.setLength(sb.length() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Generalized-Abbreviation"><a href="#Generalized-Abbreviation" class="headerlink" title="Generalized Abbreviation"></a>Generalized Abbreviation</h4><p><a href="https://leetcode.com/problems/generalized-abbreviation/" target="_blank" rel="noopener">320. Generalized Abbreviation</a></p>
<p>这一题的子函数主体部分分为两种情况讨论：</p>
<ul>
<li>不加入单词，不加入数字，count+1，start+1</li>
<li>加入单词<ul>
<li>数字不为0：加入数字，加入单词，count 归零，start+1</li>
<li>数字为0：直接加入单词，count归零，start+1</li>
</ul>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateAbbreviations</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        helper(res, <span class="keyword">new</span> StringBuilder(), word, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(List&lt;String&gt; res, StringBuilder sb, String word, <span class="keyword">int</span> count, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == word.length())&#123;</span><br><span class="line">          <span class="keyword">if</span> (count != <span class="number">0</span>) &#123;</span><br><span class="line">              sb.append(count);</span><br><span class="line">             </span><br><span class="line">          &#125;</span><br><span class="line">             res.add(sb.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = sb.length();</span><br><span class="line">        helper(res,sb,word,count+<span class="number">1</span>,start+<span class="number">1</span>);</span><br><span class="line">        sb.setLength(len);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(count&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            sb.append(count);</span><br><span class="line">            sb.append(word.charAt(start));</span><br><span class="line">            helper(res,sb,word,<span class="number">0</span>,start+<span class="number">1</span>);</span><br><span class="line">            sb.setLength(len);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            sb.append(word.charAt(start));</span><br><span class="line">            helper(res, sb, word, <span class="number">0</span>, start+<span class="number">1</span>);</span><br><span class="line">            sb.setLength(len);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Restore-IP-Addresses"><a href="#Restore-IP-Addresses" class="headerlink" title="Restore IP Addresses"></a>Restore IP Addresses</h4><p><a href="https://leetcode.com/problems/restore-ip-addresses/" target="_blank" rel="noopener">93. Restore IP Addresses</a></p>
<p>这一题最主要是需要注意递归出口和子函数主干部分基于 IP 地址有效性的两个判断语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (start &gt; s.length() || s.length()-start &lt; set || s.length() - start &gt; set*<span class="number">3</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(start+i&lt;=s.length() &amp;&amp; ((i != <span class="number">3</span> || Integer.valueOf(s.substring(start,start+i))&lt;<span class="number">256</span>) &amp;&amp; (i==<span class="number">1</span> || Integer.valueOf(s.substring(start,start+<span class="number">1</span>))!=<span class="number">0</span>))) &#123;</span><br></pre></td></tr></table></figure>
<p>第一个判断语句比较好理解，第二个相对复杂一些：</p>
<ol>
<li>这一次截断不会超过整个 String 的长度</li>
<li>如果i 的长度是3的话，我们需要判断是否会超过256造成无效</li>
<li>如果i 的长度不是1的话，我们需要判断是否由0开头造成无效</li>
</ol>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">restoreIpAddresses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(s.length()&lt;<span class="number">4</span> || s.length()&gt;<span class="number">12</span>) <span class="keyword">return</span> res;</span><br><span class="line">        helper(res, <span class="keyword">new</span> StringBuilder(),s,<span class="number">4</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(List&lt;String&gt; res, StringBuilder sb, String s, <span class="keyword">int</span> set, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; s.length() || s.length()-start &lt; set || s.length() - start &gt; set*<span class="number">3</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (set==<span class="number">0</span> &amp;&amp; start == s.length())&#123;</span><br><span class="line">            sb.setLength(sb.length()-<span class="number">1</span>);</span><br><span class="line">            res.add(sb.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = sb.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(start+i&lt;=s.length() &amp;&amp; ((i != <span class="number">3</span> || Integer.valueOf(s.substring(start,start+i))&lt;<span class="number">256</span>) &amp;&amp; (i==<span class="number">1</span> || Integer.valueOf(s.substring(start,start+<span class="number">1</span>))!=<span class="number">0</span>))) &#123;</span><br><span class="line">                sb.append(s.substring(start,start+i)).append(<span class="string">"."</span>);</span><br><span class="line">                helper (res,sb,s,set-<span class="number">1</span>,start+i);</span><br><span class="line">                sb.setLength(len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Expression-Add-Operators"><a href="#Expression-Add-Operators" class="headerlink" title="Expression Add Operators"></a>Expression Add Operators</h4><p><a href="https://leetcode.com/problems/expression-add-operators/" target="_blank" rel="noopener">282.Expression Add Operators</a></p>
<p>这题的难点在于要处理一个特别的 case，正常递归2+2+3是很好处理的，问题是2+2*3该怎么办？所以我们在传入递归函数中还需要再加入一个mult 值来应对这种情况。</p>
<p>然后是对子函数主干的分析：</p>
<ol>
<li>当我们截取的这个数字不止1位数时，我们需要判断是否出现头部是0造成不合法的情况。</li>
<li>当 start==0的时候，也就是第一次递归，我们不存在要减去，加上或乘以上一位数的情况。</li>
<li>当 start 不为0的时候我们需要考虑三种情况：<ul>
<li>$cur+pre$ 作为当前的值，并且把 cur 存成 mult以供后用</li>
<li>$cur-pre$ 作为当前的值，并且把  -cur 存成 mult 以供后用</li>
<li>$pre-mult+mult\bullet cur$ 作为当前的值，并且把$mult\bullet cur$存成 mult 以供后用</li>
</ul>
</li>
<li>还要注意，String 转化为 Integer极其容易越界，所以我们 使用 long（long 和 Long 是不一样的）存储 cur 和 mult。</li>
</ol>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">addOperators</span><span class="params">(String num, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        helper(num, target, res, <span class="keyword">new</span> StringBuilder(), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(String num, <span class="keyword">int</span> target, List&lt;String&gt; res, StringBuilder sb, <span class="keyword">int</span> start, <span class="keyword">long</span> cur, <span class="keyword">long</span> mult)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == num.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur == target) &#123;</span><br><span class="line">                res.add(sb.toString());</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; num.length(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != start &amp;&amp; num.charAt(start) == <span class="string">'0'</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> len = sb.length();</span><br><span class="line">                <span class="keyword">long</span> sub = Long.valueOf(num.substring(start, i + <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">if</span> (start == <span class="number">0</span>) &#123;</span><br><span class="line">                    helper(num, target, res, sb.append(sub), i + <span class="number">1</span>, sub, sub);</span><br><span class="line">                    sb.setLength(len);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    helper(num, target, res, sb.append(<span class="string">'+'</span>).append(sub), i + <span class="number">1</span>, sub + cur, sub);</span><br><span class="line">                    sb.setLength(len);</span><br><span class="line">                    helper(num, target, res, sb.append(<span class="string">'-'</span>).append(sub), i + <span class="number">1</span>, cur - sub, -sub);</span><br><span class="line">                    sb.setLength(len);</span><br><span class="line">                    helper(num, target, res, sb.append(<span class="string">'*'</span>).append(sub), i + <span class="number">1</span>, cur - mult + mult * sub, mult * sub);</span><br><span class="line">                    sb.setLength(len);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Word-Break-II"><a href="#Word-Break-II" class="headerlink" title="Word Break II"></a>Word Break II</h4><p><a href="https://leetcode.com/problems/word-break-ii/" target="_blank" rel="noopener">140. Word Break II</a></p>
<p>常规的递归过程并不难，但是却过不了所有的 test case，因为在 lc 的 test case 里有一个超长的String 会造成递归的冗余。在前面的题目中，我们已经知道了 dp 是面对大量的冗余时异常好的办法。在这里，我们想要知道的问题是， 这个问题在 index i 的之后的 substring 里有解吗？如果没有解，我们直接break 就行了，也不用继续递归下去了。</p>
<p>所以，我们可以定义<code>dp[s.length()+1]</code>将<code>dp[s.length()]==true</code>作为初始化，因为我们知道整个字符串必然有解，事实上这道题让我们求的就是枚举所有可能解。</p>
<p>然后我们写出转移方程式：</p>
<p><code>if (set.contains(s.substring(i,j+1)) &amp;&amp; dp[j+1])</code></p>
<p>这句话的意思是，当从 i到 j 的字符串被字典包含的时候，只要 j+1后的子问题有解，这个问题也就有解了。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;(wordDict);</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()+<span class="number">1</span>];</span><br><span class="line">        dp[s.length()] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=s.length()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;--i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i; j&lt;s.length();++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(set.contains(s.substring(i,j+<span class="number">1</span>)) &amp;&amp; dp[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    dp[i] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        helper(s,set,res,<span class="keyword">new</span> StringBuilder(),dp,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(String s, Set&lt;String&gt; set, List&lt;String&gt; res, StringBuilder sb, <span class="keyword">boolean</span>[] dp, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == s.length()) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = sb.length();</span><br><span class="line">            sb.setLength(len-<span class="number">1</span>);</span><br><span class="line">            res.add(sb.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; s.length(); i++) &#123;</span><br><span class="line">                String ss = s.substring(start,i+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(!set.contains(ss)||dp[i+<span class="number">1</span>]==<span class="keyword">false</span>) <span class="keyword">continue</span>;</span><br><span class="line">                 <span class="keyword">int</span> len = sb.length();</span><br><span class="line"></span><br><span class="line">                    sb.append(ss).append(<span class="string">" "</span>);</span><br><span class="line">                    helper(s,set,res,sb,dp,i+<span class="number">1</span>);</span><br><span class="line">                    sb.setLength(len);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="Word-Pattern"><a href="#Word-Pattern" class="headerlink" title="Word Pattern"></a>Word Pattern</h4><p><a href="https://leetcode.com/problems/word-pattern-ii/" target="_blank" rel="noopener">Word Pattern II</a></p>
<ol>
<li><p>涉及到String a 与 String b 的匹配问题，无可避免地需要使用 HashMap 来记录匹配情况。</p>
</li>
<li><p>如果我们把一个substring 匹配给了一个 字母，那么在之后的遍历中，我们便不能再把这个 substring 匹配给别的 Character 了，所以我们还需要一个 HashSet来记录我们已经匹配过的substring。</p>
</li>
<li><p>显然我们需要两个 start 指针 i 和 j 来标记匹配到了哪里，出口判断语句是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (i == pattern.length() &amp;&amp; j == str.length()) return true;</span><br><span class="line">if (i == pattern.length() || j == str.length()) return false;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 backtrcking 函数的主题部分，我们需要考虑两点：</p>
<ul>
<li>map包含 i 所指向的字母;<ul>
<li>如果从j 开始的 substring 等于 map get 到的 value 的话则(return)继续递归，这个比较我们可以用 <code>b.startsWith()</code>函数实现。</li>
<li>如果两者 value 不相等则直接 return false。</li>
</ul>
</li>
<li>map 如果不包含 i 所指向地字母，则我们进行常规的for 循环遍历递归<ul>
<li>注意这里是<code>if (helper(pattern,i+1,str,j+ss.length(),map,set)) return true;</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordPatternMatch</span><span class="params">(String pattern, String str)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Character, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> helper(pattern,<span class="number">0</span>,str,<span class="number">0</span>,map,set);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(String pattern, <span class="keyword">int</span> i, String str, <span class="keyword">int</span> j, HashMap&lt;Character,String&gt; map, Set&lt;String&gt; set)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == pattern.length() &amp;&amp; j == str.length()) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (i == pattern.length() || j == str.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">char</span> c = pattern.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(c)) &#123;</span><br><span class="line">            String s = map.get(c);</span><br><span class="line">            <span class="keyword">if</span>(!str.startsWith(s,j)) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> helper(pattern,i+<span class="number">1</span>,str,j+s.length(),map,set);</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> a = j;a&lt;str.length();a++) &#123;</span><br><span class="line">                String ss = str.substring(j,a+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(set.contains(ss))  <span class="keyword">continue</span>;</span><br><span class="line">                map.put(c,ss);</span><br><span class="line">                set.add(ss);</span><br><span class="line">                <span class="keyword">if</span> (helper(pattern,i+<span class="number">1</span>,str,j+ss.length(),map,set)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                 map.remove(c);</span><br><span class="line">                 set.remove(ss);</span><br><span class="line">            &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="与-DFS-BFS-的水乳交融"><a href="#与-DFS-BFS-的水乳交融" class="headerlink" title="与 DFS/BFS 的水乳交融"></a>与 DFS/BFS 的水乳交融</h2><h3 id="Android-Unlock-Patterns"><a href="#Android-Unlock-Patterns" class="headerlink" title="Android Unlock Patterns"></a>Android Unlock Patterns</h3><p><a href="https://leetcode.com/problems/android-unlock-patterns/" target="_blank" rel="noopener">351. Android Unlock Patterns</a></p>
<script type="math/tex; mode=display">\begin{matrix}
1&2&3\\
4&5&6\\
7&8&9\\
\end{matrix}</script><p><a href="https://www.cnblogs.com/grandyang/p/5541012.html" target="_blank" rel="noopener">以下解释 copy自 grandyang</a></p>
<p>我们建立一个二维数组jumps，用来记录两个数字键之间是否有中间键，然后再用一个一位数组visited来记录某个键是否被访问过，然后我们用递归来解，我们先对1调用递归函数，在递归函数中，我们遍历1到9每个数字next，然后找他们之间是否有jump数字，如果next没被访问过，并且jump为0，或者jump被访问过，我们对next调用递归函数。数字1的模式个数算出来后，由于1,3,7,9是对称的，所以我们乘4即可，然后再对数字2调用递归函数，2,4,6,9也是对称的，再乘4，最后单独对5调用一次，然后把所有的加起来就是最终结果了</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfPatterns</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] skip = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">boolean</span>[] vis = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">        skip[<span class="number">1</span>][<span class="number">3</span>] = skip[<span class="number">3</span>][<span class="number">1</span>] =<span class="number">2</span>;</span><br><span class="line">        skip[<span class="number">1</span>][<span class="number">7</span>] = skip[<span class="number">7</span>][<span class="number">1</span>] =<span class="number">4</span>;</span><br><span class="line">        skip[<span class="number">7</span>][<span class="number">9</span>] = skip[<span class="number">9</span>][<span class="number">7</span>] = <span class="number">8</span>;</span><br><span class="line">        skip[<span class="number">9</span>][<span class="number">3</span>] = skip[<span class="number">3</span>][<span class="number">9</span>] =<span class="number">6</span>;</span><br><span class="line">        skip[<span class="number">1</span>][<span class="number">9</span>] = skip[<span class="number">9</span>][<span class="number">1</span>] = skip[<span class="number">3</span>][<span class="number">7</span>] = skip[<span class="number">7</span>][<span class="number">3</span>] = skip[<span class="number">2</span>][<span class="number">8</span>]=skip[<span class="number">8</span>][<span class="number">2</span>]=skip[<span class="number">4</span>][<span class="number">6</span>]=skip[<span class="number">6</span>][<span class="number">4</span>]=<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=m; i&lt;=n; i++) &#123;</span><br><span class="line">            res+=helper(skip,vis,i-<span class="number">1</span>,<span class="number">1</span>)*<span class="number">4</span>;</span><br><span class="line">            res+=helper(skip,vis,i-<span class="number">1</span>,<span class="number">2</span>)*<span class="number">4</span>;</span><br><span class="line">            res+=helper(skip,vis,i-<span class="number">1</span>,<span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[][] skip, <span class="keyword">boolean</span>[] vis, <span class="keyword">int</span> remain, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(remain == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(remain &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vis[start] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">9</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i] || (!vis[skip[start][i]] &amp;&amp; skip[start][i]!=<span class="number">0</span>)) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            res+=helper(skip,vis,remian-<span class="number">1</span>,i);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        vis[start] = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Dubliner</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2019/06/LeetCode中的Backtracking总结/">http://yoursite.com/2019/06/LeetCode中的Backtracking总结/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/LeetCode分类总结/">LeetCode分类总结</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/06/LeetCode中的BinarySearchTree总结/"><i class="fa fa-chevron-left">  </i><span>LeetCode 中的 Binary Search Tree 总结</span></a></div><div class="next-post pull-right"><a href="/2019/06/LeetCode中的DynamicProgramming/"><span>LeetCode 中的 Dynamic Programming总结</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(/bg.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2019 By Dubliner</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script><!-- hexo-inject:begin --><!-- hexo-inject:end --></body></html>