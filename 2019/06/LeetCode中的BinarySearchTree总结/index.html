<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="LeetCode 中的 Binary Search Tree 总结"><meta name="keywords" content="LeetCode分类总结,查找"><meta name="author" content="Dubliner"><meta name="copyright" content="Dubliner"><title>LeetCode 中的 Binary Search Tree 总结 | Dubliner</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script><!-- hexo-inject:begin --><!-- hexo-inject:end -->var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><!-- hexo-inject:begin --><!-- hexo-inject:end --></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#检查与查找"><span class="toc-number">1.</span> <span class="toc-text">检查与查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基于二叉树遍历"><span class="toc-number">1.1.</span> <span class="toc-text">基于二叉树遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#中序遍历复习"><span class="toc-number">1.1.1.</span> <span class="toc-text">中序遍历复习</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Recursive-1"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">Recursive (1)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Recursive-2"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">Recursive (2)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Iterative"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">Iterative</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Validate-Binary-Search-Tree"><span class="toc-number">1.1.2.</span> <span class="toc-text">Validate Binary Search Tree</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Binary-Search-Tree-Iterator"><span class="toc-number">1.1.3.</span> <span class="toc-text">Binary Search Tree Iterator</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Closest-Binary-Search-Tree-Value-II"><span class="toc-number">1.1.4.</span> <span class="toc-text">Closest Binary Search Tree Value II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Recover-Binary-Search-Tree"><span class="toc-number">1.1.5.</span> <span class="toc-text">Recover Binary Search Tree</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Verify-Preorder-Sequence-in-Binary-Search-Tree"><span class="toc-number">1.1.6.</span> <span class="toc-text">Verify Preorder Sequence in Binary Search Tree</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基于BST特性以及分治思想"><span class="toc-number">1.2.</span> <span class="toc-text">基于BST特性以及分治思想</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Lowest-Common-Ancestor-of-a-Binary-Search-Tree"><span class="toc-number">1.2.1.</span> <span class="toc-text">Lowest Common Ancestor of a Binary Search Tree</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Kth-Smallest-Element-in-a-BST"><span class="toc-number">1.2.2.</span> <span class="toc-text">Kth Smallest Element in a BST</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#方法一：BST特性"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">方法一：BST特性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#方法二：Inorder-Recursive"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">方法二：Inorder Recursive</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#方法三：Inorder-Iterative"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">方法三：Inorder Iterative</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Follow-Up"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">Follow Up</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Inorder-Successor-in-BST"><span class="toc-number">1.2.3.</span> <span class="toc-text">Inorder Successor in BST</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Closest-Binary-Search-Tree-Value"><span class="toc-number">1.2.4.</span> <span class="toc-text">Closest Binary Search Tree Value</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Largest-BST-Subtree"><span class="toc-number">1.2.5.</span> <span class="toc-text">Largest BST Subtree</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构造与转化"><span class="toc-number">2.</span> <span class="toc-text">构造与转化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基于树的遍历"><span class="toc-number">2.1.</span> <span class="toc-text">基于树的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Serialize-and-Deserialize-Binary-Tree"><span class="toc-number">2.1.1.</span> <span class="toc-text">Serialize and Deserialize Binary Tree</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基于BST特性与分治思想"><span class="toc-number">2.2.</span> <span class="toc-text">基于BST特性与分治思想</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Convert-Sorted-List-to-Binary-Search-Tree"><span class="toc-number">2.2.1.</span> <span class="toc-text">Convert Sorted List to Binary Search Tree</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Convert-Sorted-List-to-Binary-Search-Tree-1"><span class="toc-number">2.2.2.</span> <span class="toc-text">Convert Sorted List to Binary Search Tree</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Unique-Binary-Search-Trees"><span class="toc-number">2.2.3.</span> <span class="toc-text">Unique Binary Search Trees</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Unique-Binary-Search-Trees-II"><span class="toc-number">2.2.4.</span> <span class="toc-text">Unique Binary Search Trees II</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/head.jpg"></div><div class="author-info__name text-center">Dubliner</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">6</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">3</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">8</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/bg.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Dubliner</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">主页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span></div><div id="post-info"><div id="post-title">LeetCode 中的 Binary Search Tree 总结</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-06-03</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/LeetCode/">LeetCode</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/LeetCode/DataStructures/">DataStructures</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/LeetCode/DataStructures/BinarySearchTree/">BinarySearchTree</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="检查与查找"><a href="#检查与查找" class="headerlink" title="检查与查找"></a>检查与查找</h2><h3 id="基于二叉树遍历"><a href="#基于二叉树遍历" class="headerlink" title="基于二叉树遍历"></a>基于二叉树遍历</h3><h4 id="中序遍历复习"><a href="#中序遍历复习" class="headerlink" title="中序遍历复习"></a>中序遍历复习</h4><p>在Binary Search的总结中，我们已经详细地讲解过中序遍历的各种方法。因为二分搜索树按照中序遍历输出数组正好是从小到大排列的原因，我们将会屡次用到这种方式。在此，再一次贴出recursion和Iterative的方法作为之后做题的基本模板。</p>
<!-- hexo-inject:begin --><!-- hexo-inject:end --><h5 id="Recursive-1"><a href="#Recursive-1" class="headerlink" title="Recursive (1)"></a>Recursive (1)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        res.addAll(inorderTraversal(root.left));</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        res.addAll(inorderTraversal(root.right));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Recursive-2"><a href="#Recursive-2" class="headerlink" title="Recursive (2)"></a>Recursive (2)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        helper(root,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        helper(root.left,res);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        helper(root.right,res);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Iterative"><a href="#Iterative" class="headerlink" title="Iterative"></a>Iterative</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode p = root;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() || p!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(p);</span><br><span class="line">                p=p.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                TreeNode cur = stack.pop();</span><br><span class="line">                res.add(cur.val);</span><br><span class="line">                p = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="Validate-Binary-Search-Tree"><a href="#Validate-Binary-Search-Tree" class="headerlink" title="Validate Binary Search Tree"></a>Validate Binary Search Tree</h4><p><a href="Validate Binary Search Tree">98. Validate Binary Search Tree</a></p>
<p>一棵二叉搜索树的特性是，按照中序遍历输出数组正好是从小到大排列的。所以，我们只需要复制一次中序遍历的模板，将<code>res.add(cur.val);</code>改为<code>if (pre !=null &amp;&amp; cur.val &lt;= pre.val) return false;</code>并且新增一个<code>pre</code>指针指向当前节点的前一个结点帮助判断即可。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode p = root;</span><br><span class="line">    TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty() || p!=<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(p);</span><br><span class="line">            p = p.left;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            TreeNode cur = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (pre!=<span class="keyword">null</span> &amp;&amp; cur.val &lt;= pre.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            pre = cur;</span><br><span class="line">            p = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Binary-Search-Tree-Iterator"><a href="#Binary-Search-Tree-Iterator" class="headerlink" title="Binary Search Tree Iterator"></a>Binary Search Tree Iterator</h4><p><a href="https://leetcode.com/problems/binary-search-tree-iterator/" target="_blank" rel="noopener">173. Binary Search Tree Iterator</a></p>
<p>这一题的代码就是中序遍历的模板，但为了实现每次时间复杂度是$O(h)$，我们一开始只将root一路到最左下的叶子结点压入stack中，等到pop出来的时候再分别压入每个点的右结点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> </span>&#123;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BSTIterator</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        helper(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (root!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** <span class="doctag">@return</span> the next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TreeNode cur = stack.pop();</span><br><span class="line">        helper(cur.right);</span><br><span class="line">        <span class="keyword">return</span> cur.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** <span class="doctag">@return</span> whether we have a next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Closest-Binary-Search-Tree-Value-II"><a href="#Closest-Binary-Search-Tree-Value-II" class="headerlink" title="Closest Binary Search Tree Value II"></a>Closest Binary Search Tree Value II</h4><p><a href="https://leetcode.com/problems/closest-binary-search-tree-value-ii/" target="_blank" rel="noopener">272. Closest Binary Search Tree Value II</a></p>
<p>找最接近target的N个点，利用中序遍历从小到大的特性进行找寻。当遍历到一个节点时，如果此时结果数组不到k个，我们直接将此节点值加入res中，如果该节点值和目标值的差值的绝对值小于res的首元素和目标值差值的绝对值，说明当前值更靠近目标值，则将首元素删除，末尾加上当前节点值，反之的话说明当前值比res中所有的值都更偏离目标值，由于中序遍历的特性，之后的值会更加的遍历，所以此时直接返回最终结果即可。</p>
<p>注意定义的时候要定义成LinkedList。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">closestKValues</span><span class="params">(TreeNode root, <span class="keyword">double</span> target, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        helper(root,target,k,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root, <span class="keyword">double</span> target, <span class="keyword">int</span> k ,LinkedList&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        helper(root.left,target,k,res);</span><br><span class="line">        <span class="keyword">if</span>(k == res.size()) &#123;</span><br><span class="line">           <span class="keyword">if</span> (Math.abs(target-root.val) &lt; Math.abs(target-res.peekFirst())) &#123;</span><br><span class="line">               res.removeFirst();</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        helper(root.right,target,k,res);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Recover-Binary-Search-Tree"><a href="#Recover-Binary-Search-Tree" class="headerlink" title="Recover Binary Search Tree"></a>Recover Binary Search Tree</h4><p><a href="https://leetcode.com/problems/recover-binary-search-tree/" target="_blank" rel="noopener">99. Recover Binary Search Tree</a></p>
<p>在中序遍历的模板上进行添加。</p>
<p>What is the business we are doing here?<br>We need to find the first and second elements that are not in order right?</p>
<p>How do we find these two elements? For example, we have the following tree that is printed as in order traversal:</p>
<p>6, 3, 4, 5, 2</p>
<p>We compare each node with its next one and we can find out that 6 is the first element to swap because 6 &gt; 3 and 2 is the second element to swap because 2 &lt; 5.</p>
<p>Really, what we are comparing is the current node and its previous node in the “in order traversal”.</p>
<p>Let us define three variables, firstElement, secondElement, and prevElement. Now we just need to build the “do some business” logic as finding the two elements. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    TreeNode first = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode second = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode pre = <span class="keyword">new</span> TreeNode(Integer.MIN_VALUE);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        helper(root);</span><br><span class="line">      <span class="keyword">int</span> temp = first.val;</span><br><span class="line">        first.val= second.val;</span><br><span class="line">        second.val = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        helper(root.left);</span><br><span class="line">        <span class="keyword">if</span> (first == <span class="keyword">null</span> &amp;&amp; root.val &lt;= pre.val) &#123;</span><br><span class="line">            first = pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (first != <span class="keyword">null</span> &amp;&amp; root.val &lt;= pre.val) &#123;</span><br><span class="line">            second = root;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = root;</span><br><span class="line">        helper(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Verify-Preorder-Sequence-in-Binary-Search-Tree"><a href="#Verify-Preorder-Sequence-in-Binary-Search-Tree" class="headerlink" title="Verify Preorder Sequence in Binary Search Tree"></a>Verify Preorder Sequence in Binary Search Tree</h4><p><a href="https://leetcode.com/problems/verify-preorder-sequence-in-binary-search-tree/" target="_blank" rel="noopener">255. Verify Preorder Sequence in Binary Search Tree</a></p>
<ol>
<li>Create an empty stack.</li>
<li>Initialize root as INT_MIN.</li>
<li>Do following for every element pre[i]<ul>
<li>If pre[i] is smaller than current root, return false.</li>
<li>Keep removing elements from stack while pre[i] is greater  then stack top. Make the last removed item as new root (to be compared next). At this point, pre[i] is greater than the removed root  (That is why if we see a smaller element in step a), we return false)</li>
<li>push pre[i] to stack (All elements in stack are in decreasing order)  </li>
</ul>
</li>
</ol>
<p><img src="/2019/06/LeetCode中的BinarySearchTree总结/255.gif" alt="255"></p>
<p>这个解法是根据前序遍历的性质，设一个最小值low，然后遍历数组，如果当前值小于这个最小值low，返回false，对于根节点，我们将其压入栈中，然后往后遍历，如果遇到的数字比栈顶元素小，说明是其左子树的点，继续压入栈中，直到遇到的数字比栈顶元素大，那么就是右边的值了，我们需要找到是哪个节点的右子树，所以我们更新low值并删掉栈顶元素，然后继续和下一个栈顶元素比较，如果还是大于，则继续更新low值和删掉栈顶，直到栈为空或者当前栈顶元素大于当前值停止，压入当前值，这样如果遍历完整个数组之前都没有返回false的话，最后返回true即可。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verifyPreorder</span><span class="params">(<span class="keyword">int</span>[] preorder)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> min=Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:preorder)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num&lt;min)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty()&amp;&amp;num&gt;stack.peek())&#123;</span><br><span class="line">                min=stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以将代码进行空间上的优化，舍弃stack在原有Array上使用指针代替实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verifyPreorder</span><span class="params">(<span class="keyword">int</span>[] preorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> i = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p : preorder) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p &lt; low) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">while</span> (i!= -<span class="number">1</span> &amp;&amp; preorder[i] &lt; p) &#123;</span><br><span class="line">                low = preorder[i--];</span><br><span class="line">            &#125;</span><br><span class="line">            preorder[++i] = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="基于BST特性以及分治思想"><a href="#基于BST特性以及分治思想" class="headerlink" title="基于BST特性以及分治思想"></a>基于BST特性以及分治思想</h3><h4 id="Lowest-Common-Ancestor-of-a-Binary-Search-Tree"><a href="#Lowest-Common-Ancestor-of-a-Binary-Search-Tree" class="headerlink" title="Lowest Common Ancestor of a Binary Search Tree"></a>Lowest Common Ancestor of a Binary Search Tree</h4><p><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/" target="_blank" rel="noopener">235. Lowest Common Ancestor of a Binary Search Tree</a></p>
<p><em>这一题在Binary Tree中还有一道镜像题</em> <a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">236. Lowest Common Ancestor of a Binary Tree</a></p>
<p>题意是让我们想要找到最小的公共根。通过BST的特性我们知道，如果p和q的值都比root小的话，那么res必然在左子树，如果都比root大的话则在右子树，如果在二者之间的话，那么这个root就是我们要找的res。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) <span class="keyword">return</span> lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) <span class="keyword">return</span> lowestCommonAncestor(root.right,p,q);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Kth-Smallest-Element-in-a-BST"><a href="#Kth-Smallest-Element-in-a-BST" class="headerlink" title="Kth Smallest Element in a BST"></a>Kth Smallest Element in a BST</h4><p><a href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/" target="_blank" rel="noopener">230. Kth Smallest Element in a BST</a></p>
<p>这一题即可以用基于BST的特性二分的方法写，也可以直接中序遍历写，但follow up需要用BST的特性写，所以还是将这一题分在这一类当中。</p>
<h5 id="方法一：BST特性"><a href="#方法一：BST特性" class="headerlink" title="方法一：BST特性"></a>方法一：BST特性</h5><p>按照BST 左&lt;根&lt;右的特性，我们写一个count函数count左子树有多少node，如果左子树的node数量小于等于k的话说明我们要找的数在右子树，我们继续去右子树找，不然的话我们就去左子树找，如果正好等于count+1的话，那么直接return root就可以了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> count = helper(root.left);</span><br><span class="line">        <span class="keyword">if</span> (count &gt;= k) &#123;</span><br><span class="line">            <span class="keyword">return</span> kthSmallest(root.left,k);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (count+<span class="number">1</span>&lt;k) &#123;</span><br><span class="line">            <span class="keyword">return</span> kthSmallest(root.right,k-count-<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(root.left) + helper (root.right) +<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="方法二：Inorder-Recursive"><a href="#方法二：Inorder-Recursive" class="headerlink" title="方法二：Inorder Recursive"></a>方法二：Inorder Recursive</h5><p>在中序遍历recursive的模板上进行修改</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        count =k;</span><br><span class="line">        res = <span class="number">0</span>;</span><br><span class="line">        helper(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        helper(root.left);</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>) &#123;</span><br><span class="line">            res = root.val;</span><br><span class="line">            <span class="keyword">return</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        helper(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="方法三：Inorder-Iterative"><a href="#方法三：Inorder-Iterative" class="headerlink" title="方法三：Inorder Iterative"></a>方法三：Inorder Iterative</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">         Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode p = root;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() || p!= <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(p!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(p);</span><br><span class="line">                p=p.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                TreeNode cur = stack.pop();</span><br><span class="line">                k--;</span><br><span class="line">                <span class="keyword">if</span>(k==<span class="number">0</span>) <span class="keyword">return</span> cur.val;</span><br><span class="line">                p = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Follow-Up"><a href="#Follow-Up" class="headerlink" title="Follow Up"></a>Follow Up</h5><p><strong>What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?</strong></p>
<p><strong>O(h) (h = height) time complexity by modify TreeNode structure and add left subtree node count and find kth smallest element</strong> base on (<a href="http://www.geeksforgeeks.org/find-k-th-smallest-element-in-bst-order-statistics-in-bst/" target="_blank" rel="noopener">http://www.geeksforgeeks.org/find-k-th-smallest-element-in-bst-order-statistics-in-bst/</a>)</p>
<p>The idea is to maintain rank of each node. We can keep track of elements in a subtree of any node while building the tree. Since we need K-th smallest element, we can maintain number of elements of left subtree in every node.</p>
<p>Assume that the root is having N nodes in its left subtree. If K = N + 1, root is K-th node. If K &lt; N, we will continue our search (recursion) for the Kth smallest element in the left subtree of root. If K &gt; N + 1, we continue our search in the right subtree for the (K – N – 1)-th smallest element. Note that we need the count of elements in left subtree only.</p>
<p>1.travel tree by level and insert node into TreeNodeWithCount Tree.</p>
<p>2.find kth smallest in the TreeNodeWithCount Tree.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNodeWithCount</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">int</span> lCount;</span><br><span class="line">    TreeNodeWithCount left;</span><br><span class="line">    TreeNodeWithCount right;</span><br><span class="line">    TreeNodeWithCount(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    TreeNodeWithCount rootWithCount = createBSTWithCount(root);</span><br><span class="line">    <span class="keyword">return</span> kthSmallestWithCount(rootWithCount, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNodeWithCount <span class="title">createBSTWithCount</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    TreeNodeWithCount rootWithCount = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">        TreeNode node = queue.remove();</span><br><span class="line">        TreeNodeWithCount nodeWithCount = <span class="keyword">new</span> TreeNodeWithCount(node.val);</span><br><span class="line">        rootWithCount = insertBSTWithCount(rootWithCount, nodeWithCount);</span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">        <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rootWithCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNodeWithCount <span class="title">insertBSTWithCount</span><span class="params">(TreeNodeWithCount rootWithCount, TreeNodeWithCount nodeWithCount)</span> </span>&#123;</span><br><span class="line">    TreeNodeWithCount cur = rootWithCount, parent = rootWithCount;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        parent = cur;</span><br><span class="line">        <span class="keyword">if</span>(nodeWithCount.val &lt; cur.val) &#123;</span><br><span class="line">            cur.lCount++;</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(rootWithCount == <span class="keyword">null</span>) &#123;</span><br><span class="line">        rootWithCount = nodeWithCount;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nodeWithCount.val &lt; parent.val) &#123;</span><br><span class="line">        parent.left = nodeWithCount;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parent.right = nodeWithCount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rootWithCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallestWithCount</span><span class="params">(TreeNodeWithCount rootWithCount, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(rootWithCount != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(k == rootWithCount.lCount + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> rootWithCount.val;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(k &lt;= rootWithCount.lCount) &#123;</span><br><span class="line">            rootWithCount = rootWithCount.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            k = k - rootWithCount.lCount - <span class="number">1</span>;</span><br><span class="line">            rootWithCount = rootWithCount.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Inorder-Successor-in-BST"><a href="#Inorder-Successor-in-BST" class="headerlink" title="Inorder Successor in BST"></a>Inorder Successor in BST</h4><p><a href="https://leetcode.com/problems/inorder-successor-in-bst/" target="_blank" rel="noopener">285. Inorder Successor in BST</a></p>
<p>basically we always want to find <code>p</code>‘s closest node (in inorder traversal) and the node’s value is larger than <code>p</code>‘s value, right? That node can either be <code>p</code>‘s parent or the smallest node in <code>p</code>‘ right branch.</p>
<p>When the code runs into the else block, that means the current root is either <code>p</code>‘s parent or a node in <code>p</code>‘s right branch.</p>
<p>If it’s <code>p</code>‘s parent node, there are two scenarios: 1. <code>p</code> doesn’t have right child, in this case, the recursion will eventually return null, so <code>p</code>‘s parent is the successor; 2. <code>p</code> has right child, then the recursion will return the smallest node in the right sub tree, and that will be the answer.</p>
<p>If it’s <code>p</code>‘s right child, there are two scenarios: 1. the right child has left sub tree, eventually the smallest node from the left sub tree will be the answer; 2. the right child has no left sub tree, the recursion will return null, then the right child (root) is our answer.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">inorderSuccessor</span><span class="params">(TreeNode root, TreeNode p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.val &lt;= p.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> inorderSuccessor(root.right,p);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            TreeNode left = inorderSuccessor(root.left,p);</span><br><span class="line">            <span class="keyword">return</span> left == <span class="keyword">null</span>?root:left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Closest-Binary-Search-Tree-Value"><a href="#Closest-Binary-Search-Tree-Value" class="headerlink" title="Closest Binary Search Tree Value"></a>Closest Binary Search Tree Value</h4><p><a href="https://leetcode.com/problems/closest-binary-search-tree-value/" target="_blank" rel="noopener">270. Closest Binary Search Tree Value</a></p>
<p>我们根据和target的值进行比较可以择出在哪个子树，这也是通过BST的性质进行淘汰，还有种情况是可能root距离它最近，所以我们需要比较root和其子树。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">closestValue</span><span class="params">(TreeNode root, <span class="keyword">double</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = root.val;</span><br><span class="line">        TreeNode b = root.val &gt; target ? root.left : root.right;</span><br><span class="line">        <span class="keyword">if</span> (b==<span class="keyword">null</span>) <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">int</span> bv = closestValue(b,target);</span><br><span class="line">        <span class="keyword">return</span> Math.abs(a-target) &lt; Math.abs(bv-target) ? a : bv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Largest-BST-Subtree"><a href="#Largest-BST-Subtree" class="headerlink" title="Largest BST Subtree"></a>Largest BST Subtree</h4><p><a href="https://leetcode.com/problems/largest-bst-subtree/" target="_blank" rel="noopener">333. Largest BST Subtree</a></p>
<ol>
<li><p>我们建立一个数组<code>res[]</code>第一位存放左子树的最大值，第二位存放右子树地最小值，第三位存放直到该结点地最大subtree数量。</p>
</li>
<li><p>为了O(n)时间实现，我们只能遍历一遍树，所以我们自下而上进行遍历。判断当前的root值是否大于左子树最大值和右子树最小值，是则更新，不是则舍弃，注意虽然舍弃但要把res的第三位更新成left子树和right子树迄今为止的最大值。</p>
</li>
<li><p>注意一定要有min和max的判断，<code>return new int[]{Math.min(root.val,left[0]),Math.max(root.val,right[1]),left[2]+right[2]+1};</code>不然的话以leetcode题中给的栗子为例，在5的地方会出现如下情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">10</span>,<span class="number">5</span>,<span class="number">15</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="keyword">null</span>,<span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">   <span class="number">10</span> </span><br><span class="line">   / \ </span><br><span class="line">  <span class="number">5</span>  <span class="number">15</span> </span><br><span class="line"> / \   \ </span><br><span class="line"><span class="number">1</span>   <span class="number">8</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="/2019/06/LeetCode中的BinarySearchTree总结/test.png" alt="test"></p>
<p><strong>代码如下</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestBSTSubtree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span>[] res = helper(root);</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] helper(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;Integer.MAX_VALUE,Integer.MIN_VALUE,<span class="number">0</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] left = helper(root.left);</span><br><span class="line">        <span class="keyword">int</span>[] right = helper(root.right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (root.val &gt; left[<span class="number">1</span>] &amp;&amp; root.val &lt; right[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;Math.min(root.val,left[<span class="number">0</span>]),Math.max(root.val,right[<span class="number">1</span>]),left[<span class="number">2</span>]+right[<span class="number">2</span>]+<span class="number">1</span>&#125;;</span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;Integer.MIN_VALUE, Integer.MAX_VALUE,Math.max(left[<span class="number">2</span>],right[<span class="number">2</span>])&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="构造与转化"><a href="#构造与转化" class="headerlink" title="构造与转化"></a>构造与转化</h2><h3 id="基于树的遍历"><a href="#基于树的遍历" class="headerlink" title="基于树的遍历"></a>基于树的遍历</h3><h4 id="Serialize-and-Deserialize-Binary-Tree"><a href="#Serialize-and-Deserialize-Binary-Tree" class="headerlink" title="Serialize and Deserialize Binary Tree"></a>Serialize and Deserialize Binary Tree</h4><p><a href="https://leetcode.com/problems/serialize-and-deserialize-binary-tree/" target="_blank" rel="noopener">297. Serialize and Deserialize Binary Tree</a></p>
<p>利用preorder做这道题。虽然只是非常基础的前序遍历递归实现但是一定要注意一些细节。</p>
<ol>
<li><p>两处转换<code>que.addAll(Arrays.asList(s));</code>和<code>TreeNode root = new TreeNode(Integer.valueOf(cur));</code> </p>
</li>
<li><p><code>if (cur.equals(XX)) return null;</code>这里的判断不要习惯写成null了</p>
</li>
<li><p>这里是<code>if...else</code>语句千万不要漏了else。</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (root == null) sb.append(XX).append(sp);</span><br><span class="line">else&#123;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line">     String sp = <span class="string">","</span>;</span><br><span class="line">     String XX = <span class="string">"#"</span>;</span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb =<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        helper(root,sb);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root, StringBuilder sb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) sb.append(XX).append(sp);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">        sb.append(root.val).append(sp);</span><br><span class="line">        helper(root.left,sb);</span><br><span class="line">        helper(root.right,sb);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        String[] s = data.split(<span class="string">","</span>);</span><br><span class="line">        Queue&lt;String&gt; que = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        que.addAll(Arrays.asList(s));</span><br><span class="line">        <span class="keyword">return</span> helper2(que);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">helper2</span><span class="params">(Queue&lt;String&gt; que)</span> </span>&#123;</span><br><span class="line">        String cur = que.poll();</span><br><span class="line">        <span class="keyword">if</span> (cur.equals(XX)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(Integer.valueOf(cur));</span><br><span class="line">        root.left = helper2(que);</span><br><span class="line">        root.right = helper2(que);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="基于BST特性与分治思想"><a href="#基于BST特性与分治思想" class="headerlink" title="基于BST特性与分治思想"></a>基于BST特性与分治思想</h3><h4 id="Convert-Sorted-List-to-Binary-Search-Tree"><a href="#Convert-Sorted-List-to-Binary-Search-Tree" class="headerlink" title="Convert Sorted List to Binary Search Tree"></a>Convert Sorted List to Binary Search Tree</h4><p>利用BST的特性我们知道，根节点永远是中点，所以我们只需要递归找中点就可以了。Array找中点的方式是<strong>二分查找</strong>，而链表找中点的方式是<strong>快慢指针</strong>。</p>
<p><a href="https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/" target="_blank" rel="noopener">109. Convert Sorted List to Binary Search Tree</a></p>
<p><strong>代码</strong></p>
<p>recursive :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (end-start)/<span class="number">2</span> + start;</span><br><span class="line">        TreeNode cur = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">        cur.left = helper(nums,start,mid-<span class="number">1</span>);</span><br><span class="line">        cur.right = helper(nums,mid+<span class="number">1</span>,end);</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Iterative:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length ==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; leftStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; rightStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        stack.push(root);</span><br><span class="line">        leftStack.push(<span class="number">0</span>);</span><br><span class="line">        rightStack.push(nums.length-<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            TreeNode cur = stack.pop();</span><br><span class="line">            <span class="keyword">int</span> start = leftStack.pop();</span><br><span class="line">            <span class="keyword">int</span> end = rightStack.pop();</span><br><span class="line">            <span class="keyword">int</span> mid = (end-start)/<span class="number">2</span> + start;</span><br><span class="line">            cur.val = nums[mid];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (start&lt;= mid-<span class="number">1</span>) &#123;</span><br><span class="line">                cur.left = <span class="keyword">new</span> TreeNode(start);</span><br><span class="line">                leftStack.push(start);</span><br><span class="line">                stack.push(cur.left);</span><br><span class="line">                rightStack.push(mid-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">             <span class="keyword">if</span> (end&gt;= mid+<span class="number">1</span>) &#123;</span><br><span class="line">                cur.right = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">                  stack.push(cur.right);</span><br><span class="line">              </span><br><span class="line">                leftStack.push(mid+<span class="number">1</span>);</span><br><span class="line">               rightStack.push(end);</span><br><span class="line">               </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Convert-Sorted-List-to-Binary-Search-Tree-1"><a href="#Convert-Sorted-List-to-Binary-Search-Tree-1" class="headerlink" title="Convert Sorted List to Binary Search Tree"></a>Convert Sorted List to Binary Search Tree</h4><p>利用BST的特性我们知道，根节点永远是中点，所以我们只需要递归找中点就可以了。Array找中点的方式是<strong>二分查找</strong>，而链表找中点的方式是<strong>快慢指针</strong>。</p>
<p><a href="https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/" target="_blank" rel="noopener">109. Convert Sorted List to Binary Search Tree</a></p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">return</span> helper(head,<span class="keyword">null</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">helper</span><span class="params">(ListNode head, ListNode bound)</span> </span>&#123;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        <span class="keyword">if</span> (head == bound) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast.next!=bound &amp;&amp; fast.next.next!=bound)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode cur = <span class="keyword">new</span> TreeNode(slow.val);</span><br><span class="line">        cur.left= helper(head,slow);</span><br><span class="line">        cur.right = helper(slow.next,bound);</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Unique-Binary-Search-Trees"><a href="#Unique-Binary-Search-Trees" class="headerlink" title="Unique Binary Search Trees"></a>Unique Binary Search Trees</h4><p><a href="https://leetcode.com/problems/unique-binary-search-trees/" target="_blank" rel="noopener">96. Unique Binary Search Trees</a></p>
<p>这是一道DP题，<a href="[https://zh.wikipedia.org/wiki/%E5%8D%A1%E5%A1%94%E5%85%B0%E6%95%B0](https://zh.wikipedia.org/wiki/卡塔兰数">卡塔兰数</a>)的应用。</p>
<script type="math/tex; mode=display">C_{n+1}=\sum ^{n}_{i=0}C_{i}C_{n-i}</script><p><img src="/2019/06/LeetCode中的BinarySearchTree总结/96.png" alt="96"></p>
<p>我们把 $n = 0$ 时赋为1，因为空树也算一种二叉搜索树，那么$ n = 1 $时的情况可以看做是其左子树个数乘以右子树的个数，左右子树都是空树，所以1乘1还是1。那么 $n = 2$ 时，由于1和2都可以为根，分别算出来，再把它们加起来即可。n = 2 的情况可由下面式子算出：</p>
<script type="math/tex; mode=display">dp[2] = dp[0]\cdot dp[1]+dp[1] \cdot dp[0]</script><p>1为根的情况，则左子树一定不存在，右子树可以有一个数字；2为根的情况，则左子树可以有一个数字，右子树一定不存在。</p>
<script type="math/tex; mode=display">dp[3] =  dp[0] \cdot dp[2]+ dp[1] \cdot dp[1]+ dp[2] \cdot dp[0]</script><p>1为根的情况，则左子树一定不存在，右子树可以有两个数字；2为根的情况，则左右子树都可以各有一个数字；3为根的情况，则左子树可以有两个数字，右子树一定不存在。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] =<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j++) &#123;</span><br><span class="line">                dp[i] += dp[j] * dp[i-j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Unique-Binary-Search-Trees-II"><a href="#Unique-Binary-Search-Trees-II" class="headerlink" title="Unique Binary Search Trees II"></a>Unique Binary Search Trees II</h4><p><a href="https://leetcode.com/problems/unique-binary-search-trees-ii/" target="_blank" rel="noopener">95. Unique Binary Search Trees II</a></p>
<ol>
<li>我们分别以每个顶点作为root进行递归，左子树和右子树是子问题，所以也可以递归求解。</li>
<li>我们通过三个for循环一个遍历最大的root，第二第三分别遍历左右子树return回来的<code>List&lt;TreeNode&gt;</code>进行添加答案。</li>
<li>边界条件是<code>start&gt;end</code>,注意一定要添加null节点</li>
</ol>
<p><img src="/2019/06/LeetCode中的BinarySearchTree总结/95.png" alt="95"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n ==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">helper</span> <span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(start &gt; end) res.add(<span class="keyword">null</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">            List&lt;TreeNode&gt; left = helper(start,i-<span class="number">1</span>);</span><br><span class="line">            List&lt;TreeNode&gt; right = helper(i+<span class="number">1</span>,end);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (TreeNode l : left) &#123;</span><br><span class="line">                <span class="keyword">for</span> (TreeNode r : right) &#123;</span><br><span class="line">                    TreeNode root = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                    root.left = l;</span><br><span class="line">                    root.right = r;</span><br><span class="line">                    res.add(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Dubliner</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2019/06/LeetCode中的BinarySearchTree总结/">http://yoursite.com/2019/06/LeetCode中的BinarySearchTree总结/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/LeetCode分类总结/">LeetCode分类总结</a><a class="post-meta__tags" href="/tags/查找/">查找</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/06/LeetCode中的DynamicProgramming/"><i class="fa fa-chevron-left">  </i><span>LeetCode 中的 Dynamic Programming总结</span></a></div><div class="next-post pull-right"><a href="/2019/05/LeetCode中的BinaryTree总结/"><span>LeetCode 中的 Binary Tree 总结</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(/bg.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2019 By Dubliner</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script><!-- hexo-inject:begin --><!-- hexo-inject:end --></body></html>